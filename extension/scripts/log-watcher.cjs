#!/usr/bin/env node

/**
 * Log Watcher - Exports extension logs to a file for Cursor
 * 
 * This script connects to Chrome via the Remote Debugging Protocol
 * and continuously exports logs to a file that Cursor can read.
 * 
 * Usage:
 *   node scripts/log-watcher.js
 * 
 * Requirements:
 *   1. Chrome must be running with remote debugging enabled
 *   2. The extension must be loaded
 */

const fs = require('fs');
const path = require('path');
const WebSocket = require('ws');
const http = require('http');

const CHROME_DEBUG_PORT = 9222;
const LOG_FILE = path.join(__dirname, '..', 'EXTENSION_LOGS.txt');
const POLL_INTERVAL = 2000; // Check every 2 seconds

let lastLogCount = 0;

async function getChromeTargets() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'localhost',
      port: CHROME_DEBUG_PORT,
      path: '/json',
      method: 'GET'
    };

    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

async function executeInExtension(wsUrl, code) {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(wsUrl);
    
    ws.on('open', () => {
      ws.send(JSON.stringify({
        id: 1,
        method: 'Runtime.evaluate',
        params: {
          expression: code,
          returnByValue: true
        }
      }));
    });

    ws.on('message', (data) => {
      const response = JSON.parse(data);
      if (response.id === 1) {
        ws.close();
        if (response.result && response.result.result) {
          resolve(response.result.result.value);
        } else if (response.error) {
          reject(new Error(response.error.message));
        } else {
          resolve(null);
        }
      }
    });

    ws.on('error', reject);
  });
}

async function fetchLogs() {
  try {
    // Get all Chrome targets
    const targets = await getChromeTargets();
    
    // Find extension background page (service worker)
    const extensionTarget = targets.find(t => 
      t.type === 'service_worker' && 
      t.title.includes('SecondBrain') || 
      t.url.includes('chrome-extension://')
    );

    if (!extensionTarget) {
      console.error('âŒ Extension background page not found. Make sure the extension is loaded.');
      return null;
    }

    // Connect and fetch logs
    const code = `
      (async function() {
        const result = await chrome.storage.local.get('debug_logs');
        const logs = result.debug_logs || [];
        return logs.map(log => ({
          timestamp: log.timestamp,
          level: log.level,
          context: log.context,
          message: log.message,
          data: log.data,
          stack: log.stack
        }));
      })()
    `;

    const logs = await executeInExtension(extensionTarget.webSocketDebuggerUrl, code);
    return logs;
  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      console.error('âŒ Cannot connect to Chrome. Make sure Chrome is running with: --remote-debugging-port=9222');
    } else {
      console.error('âŒ Error fetching logs:', error.message);
    }
    return null;
  }
}

function formatLogsToText(logs) {
  if (!logs || logs.length === 0) {
    return '# Extension Debug Logs\n\nNo logs yet. Start using the extension to see logs appear here.\n';
  }

  let output = `# Extension Debug Logs\n`;
  output += `# Last updated: ${new Date().toISOString()}\n`;
  output += `# Total logs: ${logs.length}\n`;
  output += `#\n`;
  output += `# This file is auto-generated by log-watcher.js\n`;
  output += `# It updates every 2 seconds when Chrome is running with remote debugging\n`;
  output += `\n${'='.repeat(80)}\n\n`;

  logs.forEach((log, index) => {
    output += `[${log.timestamp}] [${log.context.toUpperCase()}] [${log.level.toUpperCase()}]\n`;
    output += `${log.message}\n`;
    
    if (log.data) {
      output += `\nData:\n${JSON.stringify(log.data, null, 2)}\n`;
    }
    
    if (log.stack) {
      output += `\nStack Trace:\n${log.stack}\n`;
    }
    
    output += `\n${'-'.repeat(80)}\n\n`;
  });

  return output;
}

async function watchLogs() {
  console.log('ðŸ” Log Watcher started...');
  console.log(`ðŸ“ Logs will be written to: ${LOG_FILE}`);
  console.log(`ðŸ”„ Polling every ${POLL_INTERVAL}ms\n`);

  // Initial instructions
  if (!fs.existsSync(LOG_FILE)) {
    const instructions = `# Extension Debug Logs

# SETUP REQUIRED:
# 
# To start capturing logs, run Chrome with remote debugging:
# 
# Windows:
#   chrome.exe --remote-debugging-port=9222
#
# macOS:
#   /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9222
#
# Linux:
#   google-chrome --remote-debugging-port=9222
#
# Or for Brave:
#   brave.exe --remote-debugging-port=9222
#
# Then make sure your extension is loaded and this watcher is running.
#
# Waiting for connection...
`;
    fs.writeFileSync(LOG_FILE, instructions);
  }

  setInterval(async () => {
    const logs = await fetchLogs();
    
    if (logs) {
      if (logs.length !== lastLogCount) {
        const text = formatLogsToText(logs);
        fs.writeFileSync(LOG_FILE, text);
        console.log(`âœ… Updated logs: ${logs.length} entries (${logs.length - lastLogCount} new)`);
        lastLogCount = logs.length;
      }
    }
  }, POLL_INTERVAL);
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ‘‹ Log watcher stopped');
  process.exit(0);
});

// Start watching
watchLogs();

